# -*- coding: utf-8 -*-
"""
OPTICS: Ordering Points To Identify the Clustering Structure
"""

# Author: Fredrik Appelros (fredrik.appelros@gmail.com), Carl Ekerot (kalle@implode.se)
# License: BSD

import numpy as np

from ..base import BaseEstimator, ClusterMixin
from ..utils import atleast2d_or_csr
from sklearn.neighbors import BallTree
from ._reachability_cluster_extraction import EXTRACTION_FUNCTIONS

def optics(X, eps=float('inf'), min_samples=1, metric='euclidean',
           extraction='hierarchical', ext_kwargs={}):
    """
    Perform OPTICS clustering from vector array or distance matrix.

    Parameters
    ----------
    X : array [n_samples, n_samples] or [n_samples, n_features]
        Array of distances between samples, or a feature array.
        The array is treated as a feature array unless the metric is given as
        'precomputed'.

    eps : float, optional
        The generating distance between two samples for them to be considered
        as in the same neighborhood.

    min_samples : int, optional
        The number of samples in a neighborhood for a point to be considered
        as a core point.

    metric : string or callable, optional
        The metric to use when calculating distance between instances in a
        feature array. If metric is a string or callable, it must be one of
        the options allowed by metrics.pairwise.calculate_distance for its
        metric parameter.
        If metric is "precomputed", X is assumed to be a distance matrix and
        must be square.

    extraction : string, optional
        The extraction method used to generate clusters from the ordering of
        points returned by the OPTICS algorithm.

    ext_kwargs : dict
        Keyword arguments to be supplied to the extraction function.

    Returns
    -------
    core_distances : array [n_samples]
        Core distance for each sample.

    ordering : array [n_samples]
        Indices of the samples in the order generated by OPTICS.

    reachability_distances : array [n_samples]
        Reachability distance for each sample.

    labels : array [n_samples]
        Cluster labels for each point. Noisy samples are given the label -1.

    Notes
    -----
    See examples/cluster/plot_optics.py for an example.

    References
    ----------
    Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel, and Jörg Sander.
    "OPTICS: ordering points to identify the clustering structure." ACM SIGMOD
    Record 28, no. 2 (1999): 49-60.

    """
    X = atleast2d_or_csr(X)
    n = X.shape[0]
    if min_samples > n:
        raise ValueError('min_samples must be lower than the total number of samples')
    ordering = []
    core_distances = np.ndarray(len(X))
    # Initiate reachability distances to infinity
    reachability_distances = float('inf') * np.ones(n)
    # Set reachability for first point
    reachability_distances[0] = 0
    # Construct spatial indexing structure
    if metric != 'precomputed':
        # TODO: Construct BallTree with the correct metric once the
        # metrics branch has been merged into master
        tree = BallTree(X, metric=metric)

    seeds = np.ones(n, dtype=bool)
    i = 0
    while True:
        # Mark current point as processed
        seeds[i] = False
        # Add current point to the ordering
        ordering.append(i)
        if not any(seeds):
            break
        # Calculate core distance
        if metric == 'precomputed':
            D = X[i]
            core_dist = np.sort(D)[min_samples]
        else:
            core_dist = tree.query(X[i], min_samples+1)[0][0][-1]
        core_distances[i] = core_dist

        if core_dist <= eps:
            # Get the neighbors of the current point
            if metric == 'precomputed':
                neighbors = D[seeds] <= eps
                ds = D[neighbors]
            else:
                ind, dist = tree.query_radius(X[i], eps, True)
                si = seeds[ind[0]]
                neighbors = ind[0][si]
                ds = dist[0][si]
            cds = core_dist * np.ones(len(ds))
            # Set the new reachability distances to
            # max(core_distance, distance)
            new_reach_dists = np.maximum(cds, ds)
            reachability_distances[neighbors] = new_reach_dists
            i = np.nonzero(seeds)[0][np.argmin(reachability_distances[seeds])]
        else:
            i = np.where(seeds)[0][0]

    if type(extraction) is str:
        estr = extraction.lower()
        if estr in EXTRACTION_FUNCTIONS:
            func = EXTRACTION_FUNCTIONS[estr]
            labels = func(ordering, reachability_distances, min_samples,
                    **ext_kwargs)
        else:
            raise ValueError('Unknown Extraction Method: %s' % estr)
    else:
        raise TypeError('Extraction Method must be a string.')

    return core_distances, ordering, reachability_distances, labels

class OPTICS(BaseEstimator, ClusterMixin):
    """
    Perform OPTICS clustering from vector array or distance matrix.

    Parameters
    ----------
    X : array [n_samples, n_samples] or [n_samples, n_features]
        Array of distances between samples, or a feature array.
        The array is treated as a feature array unless the metric is given as
        'precomputed'.

    eps : float, optional
        The generating distance between two samples for them to be considered
        as in the same neighborhood.

    min_samples : int, optional
        The number of samples in a neighborhood for a point to be considered
        as a core point.

    metric : string or callable, optional
        The metric to use when calculating distance between instances in a
        feature array. If metric is a string or callable, it must be one of
        the options allowed by metrics.pairwise.calculate_distance for its
        metric parameter.
        If metric is "precomputed", X is assumed to be a distance matrix and
        must be square.

    extraction : string, optional
        The extraction method used to generate clusters from the ordering of
        points returned by the OPTICS algorithm.

    ext_kwargs : dict
        Keyword arguments to be supplied to the extraction function.

    Attributes
    ----------
    `core_distances_` : array [n_samples]
        Core distance for each sample.

    `ordering_` : array [n_samples]
        Indices of the samples in the order generated by OPTICS.

    `reachability_distances_` : array [n_samples]
        Reachability distance for each sample.

    `labels_` : array [n_samples]
        Cluster labels for each point. Noisy samples are given the label -1.

    Notes
    -----
    See examples/cluster/plot_optics.py for an example.

    References
    ----------
    Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel, and Jörg Sander.
    "OPTICS: ordering points to identify the clustering structure." ACM SIGMOD
    Record 28, no. 2 (1999): 49-60.

    """
    def __init__(self, eps=float('inf'), min_samples=1, metric='euclidean',
                 extraction='hierarchical', ext_kwargs=dict()):
        self.eps = eps
        self.min_samples = min_samples
        self.metric = metric
        self.extraction = extraction
        self.ext_kwargs = ext_kwargs

    def fit(self, X):
        """
        Perform OPTICS clustering from vector array or distance matrix.

        Parameters
        ----------
        X : array [n_samples, n_samples] or [n_samples, n_features]
            Array of distances between samples, or a feature array.
            The array is treated as a feature array unless the metric is
            given as 'precomputed'.
        params : dict
            Overwrite keywords from __init__.
        """
        clust = optics(X, **self.get_params())
        (self.core_distances_, self.ordering_, self.reachability_distances_,
                self.labels_) = clust
        return self
